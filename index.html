<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artifact Gallery - Solar System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0a0a23 0%, #1a1a3a 100%);
            color: white;
            overflow: hidden;
            touch-action: none;
        }

        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #info-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 350px;
            max-height: 80vh;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            overflow-y: auto;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #info-panel.visible {
            transform: translateX(0);
        }

        #info-panel h2 {
            color: #64ffda;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        #info-panel p {
            line-height: 1.6;
            margin-bottom: 15px;
            color: #e0e0e0;
        }

        #info-panel .close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #64ffda;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: background 0.2s;
        }

        #info-panel .close-btn:hover {
            background: rgba(100, 255, 218, 0.1);
        }

        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        select, button {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid rgba(100, 255, 218, 0.3);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        select:hover, button:hover {
            border-color: #64ffda;
            background: rgba(100, 255, 218, 0.1);
        }

        #return-button {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
        }

        #return-to-system {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 1px solid rgba(100, 255, 218, 0.3);
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        #return-to-system:hover {
            border-color: #64ffda;
            background: rgba(100, 255, 218, 0.1);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #64ffda;
            font-size: 18px;
            z-index: 2000;
        }

        /* Mobile Styles */
        @media (max-width: 768px) {
            #info-panel {
                width: calc(100vw - 40px);
                right: 20px;
                max-height: 60vh;
                font-size: 14px;
            }

            #controls {
                flex-direction: row;
                flex-wrap: wrap;
            }

            select, button {
                padding: 8px 12px;
                font-size: 12px;
            }
        }

        @media (max-width: 480px) {
            #info-panel {
                width: calc(100vw - 20px);
                right: 10px;
                left: 10px;
                max-height: 50vh;
            }

            #controls {
                left: 10px;
                top: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading Galaxy...</div>
    
    <div id="canvas-container"></div>
    
    <div id="controls">
        <select id="solar-system-select">
            <option value="0">Workshop Alpha Centauri</option>
            <option value="1">Workshop Kepler-442</option>
            <option value="2">Workshop Trappist-1</option>
        </select>
        <button id="reset-camera">Reset View</button>
    </div>

    <div id="info-panel">
        <button class="close-btn" id="close-panel">&times;</button>
        <h2 id="artifact-title">Artifact Title</h2>
        <p id="artifact-description"></p>
        <div id="artifact-images"></div>
        <div id="audio-controls" style="margin-top: 15px; display: none;">
            <button id="audio-toggle" style="background: none; border: 1px solid #64ffda; color: #64ffda; padding: 8px 12px; border-radius: 5px; cursor: pointer;">
                ▶️ Play
            </button>
            <audio id="artifact-audio" style="display: none;"></audio>
        </div>
    </div>

    <div id="return-button" style="display: none;">
        <button id="return-to-system">← Return to Solar System</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class ArtifactGallery {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.artifacts = [];
                this.orbits = [];
                this.selectedArtifact = null;
                this.isTransitioning = false;
                this.worldBackground = null;
                this.stars = null;
                
                // Touch handling
                this.touchStart = null;
                this.originalTouch = null;
                this.isRotating = false;
                this.rotationSpeed = 0.002;
                this.cameraDistance = 60;
                this.cameraAngle = { theta: 0, phi: Math.PI * 0.3 };
                
                this.init();
                this.setupEventListeners();
                this.createSolarSystems();
                this.animate();
                
                setTimeout(() => {
                    const loading = document.getElementById('loading');
                    if (loading) loading.style.display = 'none';
                }, 1000);
            }

            init() {
                const container = document.getElementById('canvas-container');
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000011);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(this.renderer.domElement);

                this.createStarField();

                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                this.updateCameraPosition();
            }

            createStarField() {
                const starGeometry = new THREE.BufferGeometry();
                const starCount = 2000;
                const positions = new Float32Array(starCount * 3);
                
                for (let i = 0; i < starCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 400;
                    positions[i + 1] = (Math.random() - 0.5) * 400;
                    positions[i + 2] = (Math.random() - 0.5) * 400;
                }
                
                starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const starMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 1,
                    sizeAttenuation: false
                });
                
                this.stars = new THREE.Points(starGeometry, starMaterial);
                this.scene.add(this.stars);
            }

            updateCameraPosition() {
                const x = this.cameraDistance * Math.sin(this.cameraAngle.phi) * Math.cos(this.cameraAngle.theta);
                const y = this.cameraDistance * Math.cos(this.cameraAngle.phi);
                const z = this.cameraDistance * Math.sin(this.cameraAngle.phi) * Math.sin(this.cameraAngle.theta);
                
                this.camera.position.set(x, y, z);
                this.camera.lookAt(0, 0, 0);
            }

            setupEventListeners() {
                window.addEventListener('resize', () => this.onWindowResize());
                
                this.renderer.domElement.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.renderer.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.renderer.domElement.addEventListener('mouseup', () => this.onMouseUp());
                this.renderer.domElement.addEventListener('wheel', (e) => this.onWheel(e));
                this.renderer.domElement.addEventListener('click', (e) => this.onClick(e));
                
                this.renderer.domElement.addEventListener('touchstart', (e) => this.onTouchStart(e));
                this.renderer.domElement.addEventListener('touchmove', (e) => this.onTouchMove(e));
                this.renderer.domElement.addEventListener('touchend', (e) => this.onTouchEnd(e));
                
                this.renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

                document.getElementById('solar-system-select').addEventListener('change', (e) => {
                    this.switchSolarSystem(parseInt(e.target.value));
                });

                document.getElementById('reset-camera').addEventListener('click', () => {
                    this.resetCamera();
                });

                document.getElementById('close-panel').addEventListener('click', () => {
                    this.resetCamera();
                });

                document.getElementById('return-to-system').addEventListener('click', () => {
                    this.resetCamera();
                });

                document.getElementById('audio-toggle').addEventListener('click', () => {
                    const audio = document.getElementById('artifact-audio');
                    const button = document.getElementById('audio-toggle');
    
                    if (audio.paused) {
                        audio.play();
                        button.textContent = '⏸️ Pause';
                    } else {
                        audio.pause();
                        button.textContent = '▶️ Play';
                    }
                });
            }

            onMouseDown(event) {
                if (this.isTransitioning) return;
                this.isRotating = true;
                this.touchStart = { x: event.clientX, y: event.clientY };
            }

            onMouseMove(event) {
                if (!this.isRotating || this.isTransitioning) return;
                
                const deltaX = event.clientX - this.touchStart.x;
                const deltaY = event.clientY - this.touchStart.y;
                
                this.cameraAngle.theta -= deltaX * this.rotationSpeed;
                this.cameraAngle.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.cameraAngle.phi + deltaY * this.rotationSpeed));
                
                this.updateCameraPosition();
                
                this.touchStart = { x: event.clientX, y: event.clientY };
            }

            onMouseUp() {
                this.isRotating = false;
            }

            onTouchStart(event) {
                if (this.isTransitioning) return;
                event.preventDefault();
                if (event.touches.length === 1) {
                    this.isRotating = true;
                    this.touchStart = { 
                        x: event.touches[0].clientX, 
                        y: event.touches[0].clientY 
                    };
                    this.originalTouch = { 
                        x: event.touches[0].clientX, 
                        y: event.touches[0].clientY, 
                        time: Date.now() 
                    };
                }
            }

            onTouchMove(event) {
                if (!this.isRotating || this.isTransitioning) return;
                event.preventDefault();
                
                if (event.touches.length === 1) {
                    const deltaX = event.touches[0].clientX - this.touchStart.x;
                    const deltaY = event.touches[0].clientY - this.touchStart.y;
                    
                    this.cameraAngle.theta -= deltaX * this.rotationSpeed;
                    this.cameraAngle.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.cameraAngle.phi + deltaY * this.rotationSpeed));
                    
                    this.updateCameraPosition();
                    
                    this.touchStart = { 
                        x: event.touches[0].clientX, 
                        y: event.touches[0].clientY 
                    };
                }
            }

            onTouchEnd(event) {
                event.preventDefault();
                
                // Check if this was a tap (not a drag)
                if (this.touchStart && this.isRotating && this.originalTouch) {
                    const touchEnd = event.changedTouches[0];
                    const distance = Math.sqrt(
                        Math.pow(touchEnd.clientX - this.originalTouch.x, 2) + 
                        Math.pow(touchEnd.clientY - this.originalTouch.y, 2)
                    );
                    
                    // If finger didn't move much, treat it as a tap
                    if (distance < 10) {
                        this.onClick({
                            clientX: touchEnd.clientX,
                            clientY: touchEnd.clientY
                        });
                    }
                }
                
                this.isRotating = false;
                this.touchStart = null;
                this.originalTouch = null;
            }

            onWheel(event) {
                if (this.isTransitioning) return;
                event.preventDefault();
                
                this.cameraDistance += event.deltaY * 0.01;
                this.cameraDistance = Math.max(20, Math.min(100, this.cameraDistance));
                this.updateCameraPosition();
            }

            onClick(event) {
                if (this.isTransitioning) return;
                
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);

                const intersects = raycaster.intersectObjects(this.artifacts);
                if (intersects.length > 0) {
                    this.selectArtifact(intersects[0].object);
                } else {
                    let closestArtifact = null;
                    let closestDistance = Infinity;
                    
                    this.artifacts.forEach(artifact => {
                        const screenPos = artifact.position.clone();
                        screenPos.project(this.camera);
                        
                        const screenX = (screenPos.x + 1) * window.innerWidth / 2;
                        const screenY = (-screenPos.y + 1) * window.innerHeight / 2;
                        
                        const distance = Math.sqrt(
                            Math.pow(event.clientX - screenX, 2) + 
                            Math.pow(event.clientY - screenY, 2)
                        );
                        
                        if (distance < 50 && distance < closestDistance) {
                            closestDistance = distance;
                            closestArtifact = artifact;
                        }
                    });
                    
                    if (closestArtifact) {
                        this.selectArtifact(closestArtifact);
                    }
                }
            }

            createSolarSystems() {
                this.solarSystems = [
                    {
                        name: "Workshop Alpha Centauri",
                        artifacts: [
                            { name: "The Crystal Codex", world: "Luminara", description: "A mystical realm where knowledge crystallizes into tangible gems that pulse with inner light. Scholars mine wisdom from floating crystal caves.", color: 0x64ffda, distance: 15, background: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600", audio: "https://www.soundjay.com/misc/sounds/wind-chime-2.wav" },
                            { name: "Windweaver's Compass", world: "Aethermoor", description: "Sky-bound cities drift on eternal winds above storm-wrapped seas. Wind-riders navigate between floating islands using enchanted compasses.", color: 0xff6b6b, distance: 22, background: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600", audio: "https://www.soundjay.com/nature/sounds/wind.wav" },
                            { name: "Memory Vessel", world: "Chronos Harbor", description: "A port city existing simultaneously across multiple timelines. Merchants trade memories and experiences from parallel lives.", color: 0x4ecdc4, distance: 29, background: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600", audio: "https://www.soundjay.com/misc/sounds/clock-tick.wav" },
                            { name: "Songbird Automaton", world: "Harmonic Gardens", description: "Mechanical gardens where clockwork creatures create music from morning dew and moonlight, tended by musician-gardeners.", color: 0xffe66d, distance: 36, background: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600", audio: "https://www.soundjay.com/nature/sounds/birds.wav" }
                        ]
                    },
                    {
                        name: "Workshop Kepler-442",
                        artifacts: [
                            { name: "Dreamcatcher Net", world: "Slumbering Depths", description: "Underwater cities of sleeping giants where dream-fishers harvest nightmares and pleasant visions with nets of woven starlight.", color: 0x9b59b6, distance: 18, background: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600", audio: "https://www.soundjay.com/nature/sounds/water-bubbles.wav" },
                            { name: "Flame Heart", world: "Ember Sanctuary", description: "A volcanic monastery where fire-keepers preserve the last flames of extinct civilizations in crystalline heart-shaped vessels.", color: 0xe74c3c, distance: 25, background: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600", audio: "https://www.soundjay.com/nature/sounds/fire-burning.wav" },
                            { name: "Star Map Scroll", world: "Constellation City", description: "A metropolis built on a giant celestial map where astrologer-architects design buildings that mirror star patterns.", color: 0x3498db, distance: 32, background: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600", audio: "https://www.soundjay.com/misc/sounds/celestial.wav" }
                        ]
                    },
                    {
                        name: "Workshop Trappist-1",
                        artifacts: [
                            { name: "Growth Spiral", world: "Living Architecture", description: "Cities that grow like plants, with organic buildings that adapt and evolve. Architects plant seeds instead of laying foundations.", color: 0x2ecc71, distance: 20, background: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600", audio: "https://www.soundjay.com/nature/sounds/forest.wav" },
                            { name: "Echo Chamber", world: "Sound Realm", description: "A dimension where emotions become audible music and thoughts create visual symphonies. Silent beings communicate through pure resonance.", color: 0xf39c12, distance: 27, background: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600", audio: "https://www.soundjay.com/misc/sounds/echo.wav" },
                            { name: "Tide Turner", world: "Shifting Shores", description: "Beaches that exist in constant flux, where sand-shapers sculpt temporary cities that dissolve and reform with each tide.", color: 0x1abc9c, distance: 34, background: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600", audio: "https://www.soundjay.com/nature/sounds/ocean-waves.wav" },
                            { name: "Mirror Mask", world: "Reflection Valley", description: "A place where every surface is a mirror showing not your face, but your true nature. Mask-makers craft identities from reflected souls.", color: 0x8e44ad, distance: 41, background: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600", audio: "https://www.soundjay.com/misc/sounds/mystic.wav" },
                            { name: "Time Keeper", world: "Clockwork Canyon", description: "A vast mechanical landscape where time flows differently in each zone. Chronometer-citizens age at varying rates as they move through temporal districts.", color: 0xd35400, distance: 48, background: "https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600", audio: "https://www.soundjay.com/misc/sounds/gears.wav" }
                        ]
                    }
                ];

                this.switchSolarSystem(0);
            }

            switchSolarSystem(index) {
                this.artifacts.forEach(artifact => this.scene.remove(artifact));
                this.orbits.forEach(orbit => this.scene.remove(orbit));
                this.artifacts = [];
                this.orbits = [];

                const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
                const sunMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffaa00,
                    emissiveIntensity: 0.3
                });
                const sun = new THREE.Mesh(sunGeometry, sunMaterial);
                sun.userData.isSun = true;
                this.scene.add(sun);

                const system = this.solarSystems[index];
                system.artifacts.forEach((artifactData, i) => {
                    const orbitGeometry = new THREE.RingGeometry(artifactData.distance - 0.2, artifactData.distance + 0.2, 64);
                    const orbitMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x444444, 
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.3
                    });
                    const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
                    orbit.rotation.x = Math.PI / 2;
                    this.scene.add(orbit);
                    this.orbits.push(orbit);

                    const artifactGeometry = new THREE.BoxGeometry(3, 3, 3);
                    const artifactMaterial = new THREE.MeshLambertMaterial({ 
                        color: artifactData.color,
                        emissive: artifactData.color,
                        emissiveIntensity: 0.1
                    });
                    const artifact = new THREE.Mesh(artifactGeometry, artifactMaterial);
                    
                    const angle = (i / system.artifacts.length) * Math.PI * 2;
                    artifact.position.x = Math.cos(angle) * artifactData.distance;
                    artifact.position.z = Math.sin(angle) * artifactData.distance;
                    artifact.position.y = 0;
                    
                    artifact.userData = artifactData;
                    this.scene.add(artifact);
                    this.artifacts.push(artifact);
                });

                this.resetCamera();
            }

            selectArtifact(artifact) {
                if (this.isTransitioning) return;
                
                this.selectedArtifact = artifact;
                this.isTransitioning = true;

                this.createWorldBackground(artifact.userData.background);

                const targetPos = artifact.position.clone();
                const cameraTargetPos = targetPos.clone().add(new THREE.Vector3(5, 3, 5));

                this.artifacts.forEach(otherArtifact => {
                    if (otherArtifact !== artifact && !otherArtifact.userData.isBackground) {
                        otherArtifact.material.transparent = true;
                        const fadeOut = () => {
                            otherArtifact.material.opacity = Math.max(0, otherArtifact.material.opacity - 0.02);
                            if (otherArtifact.material.opacity > 0) {
                                requestAnimationFrame(fadeOut);
                            }
                        };
                        fadeOut();
                    }
                });

                this.orbits.forEach(orbit => {
                    orbit.material.transparent = true;
                    const fadeOut = () => {
                        orbit.material.opacity = Math.max(0, orbit.material.opacity - 0.02);
                        if (orbit.material.opacity > 0) {
                            requestAnimationFrame(fadeOut);
                        }
                    };
                    fadeOut();
                });

                // Hide the sun too
                const sun = this.scene.children.find(child => child.geometry && child.geometry.type === 'SphereGeometry' && child.geometry.parameters.radius === 2);
                if (sun) {
                    sun.material.transparent = true;
                    const fadeOut = () => {
                        sun.material.opacity = Math.max(0, sun.material.opacity - 0.02);
                        if (sun.material.opacity > 0) {
                            requestAnimationFrame(fadeOut);
                        }
                    };
                    fadeOut();
                }

                if (this.stars) {
                    this.stars.material.transparent = true;
                    const fadeOut = () => {
                        this.stars.material.opacity = Math.max(0, this.stars.material.opacity - 0.02);
                        if (this.stars.material.opacity > 0) {
                            requestAnimationFrame(fadeOut);
                        }
                    };
                    fadeOut();
                }

                const startPos = this.camera.position.clone();
                const startTime = Date.now();
                const duration = 1500;

                const animateCamera = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easeProgress = 1 - Math.pow(1 - progress, 3);

                    this.camera.position.lerpVectors(startPos, cameraTargetPos, easeProgress);
                    this.camera.lookAt(targetPos);

                    if (progress < 1) {
                        requestAnimationFrame(animateCamera);
                    } else {
                        this.isTransitioning = false;
                        this.showInfoPanel(artifact.userData);
                    }
                };

                animateCamera();
            }

    createWorldBackground(imageUrl) {
    // Create a flat plane
    const bgGeometry = new THREE.PlaneGeometry(80, 60);
    
    // Load the custom image with better error handling
    const textureLoader = new THREE.TextureLoader();
    const texture = textureLoader.load(
        imageUrl,
        // Success callback
        (texture) => {
            console.log('Background image loaded successfully:', imageUrl);
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
        },
        // Progress callback
        (progress) => {
            console.log('Loading progress:', progress);
        },
        // Error callback
        (error) => {
            console.error('Failed to load background image:', imageUrl, error);
            // Create a fallback gradient texture
            this.createFallbackBackground();
            return;
        }
    );
    
    const bgMaterial = new THREE.MeshBasicMaterial({ 
        map: texture,
        side: THREE.DoubleSide,
        transparent: false,
        opacity: 1
    });
    
    this.worldBackground = new THREE.Mesh(bgGeometry, bgMaterial);
    this.worldBackground.userData.isBackground = true;
    
    // Position it at a fixed distance behind the camera's current look direction
    const cameraDirection = new THREE.Vector3();
    this.camera.getWorldDirection(cameraDirection);
    
    // Place the background at a fixed distance in the direction the camera is looking
    this.worldBackground.position.copy(this.camera.position)
        .add(cameraDirection.multiplyScalar(50));
    
    // Make it always face the camera (perpendicular to camera direction)
    this.worldBackground.lookAt(this.camera.position);
                
    this.scene.add(this.worldBackground);

    console.log('Background plane added to scene');
}

createFallbackBackground() {
    // Create a simple gradient as fallback
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');
    
    const gradient = ctx.createLinearGradient(0, 0, 512, 512);
    gradient.addColorStop(0, '#667eea');
    gradient.addColorStop(1, '#764ba2');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 512, 512);
    
    const texture = new THREE.CanvasTexture(canvas);
    
    const bgGeometry = new THREE.PlaneGeometry(60, 40);
    const bgMaterial = new THREE.MeshBasicMaterial({ 
        map: texture,
        side: THREE.DoubleSide,
        transparent: false,
        opacity: 1
    });
    
    this.worldBackground = new THREE.Mesh(bgGeometry, bgMaterial);
    this.worldBackground.userData.isBackground = true;
    this.worldBackground.position.set(0, 0, -80);
    
    this.scene.add(this.worldBackground);
    console.log('Fallback gradient background created');
}

            showInfoPanel(artifactData) {
                document.getElementById('return-button').style.display = 'block';
                const panel = document.getElementById('info-panel');
                const title = document.getElementById('artifact-title');
                const description = document.getElementById('artifact-description');

                title.textContent = `${artifactData.name} - ${artifactData.world}`;
                description.textContent = artifactData.description;

                if (artifactData.audio) {
                    const audioControls = document.getElementById('audio-controls');
                    const audio = document.getElementById('artifact-audio');
                    const button = document.getElementById('audio-toggle');
                    
                    audioControls.style.display = 'block';
                    audio.src = artifactData.audio;
                    audio.volume = 0.3;
                    audio.loop = true;
                    button.textContent = '▶️ Play';
                    
                    // Optional: Auto-play if you want it
                    audio.play().then(() => {
                        button.textContent = '⏸️ Pause';
                    }).catch(e => {
                        console.log('Autoplay prevented, user will need to click play');
                    });
                }
                
                panel.classList.add('visible');
            }

            resetCamera() {
                if (this.isTransitioning) return;
                
                // Force close the info panel
                const panel = document.getElementById('info-panel');
                panel.classList.remove('visible');
                
                // Hide return button
                document.getElementById('return-button').style.display = 'none';
                
                // Stop audio
                const audio = document.getElementById('artifact-audio');
                audio.pause();
                audio.currentTime = 0;
                
                // Reset camera
                this.cameraDistance = 60;
                this.cameraAngle = { theta: 0, phi: Math.PI * 0.3 };
                this.updateCameraPosition();
                
                // Clear selected artifact
                this.selectedArtifact = null;
                
                // Remove background
                if (this.worldBackground) {
                    this.scene.remove(this.worldBackground);
                    this.worldBackground = null;
                }
                
                // Restore all objects
                this.artifacts.forEach(artifact => {
                    artifact.material.transparent = false;
                    artifact.material.opacity = 1;
                });
                
                this.orbits.forEach(orbit => {
                    orbit.material.transparent = true;
                    orbit.material.opacity = 0.3;
                });
                
                if (this.stars) {
                    this.stars.material.transparent = false;
                    this.stars.material.opacity = 1;
                }

                // Restore the sun
                const sun = this.scene.children.find(child => child.userData.isSun);
                if (sun) {
                    sun.material.transparent = false;
                    sun.material.opacity = 1;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                this.artifacts.forEach((artifact, i) => {
                    artifact.rotation.y += 0.01;
                    
                    if (!this.selectedArtifact || this.selectedArtifact !== artifact) {
                        const angle = Date.now() * 0.0005 + (i * Math.PI * 2 / this.artifacts.length);
                        const distance = artifact.userData.distance;
                        artifact.position.x = Math.cos(angle) * distance;
                        artifact.position.z = Math.sin(angle) * distance;
                    }
                });

                if (this.selectedArtifact && !this.isTransitioning) {
                    this.selectedArtifact.rotation.y += 0.002;
                }

                this.renderer.render(this.scene, this.camera);
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        new ArtifactGallery();
    </script>
</body>
</html>
